# Отчёт. Домашнее задание 1. Вариант 3.
## _Шарапов Егор Сергеевич, БПИ219_

В данном отчете представлены действия, проделанные для работы.\
У каждого блока действий можно найти путь до папки в котором вы сможете сами увидеть все изменения и тесты в папках **Test**.
> Попытался как-то структурировать вашу проверку, чтобы было удобно 
> идти по критерям. Рекомендую открыть всю папку как проект в **VScode** или **Atom** и удобно и быстро прыгать по ссылкам на файлы из отчета.

*В работе выполнены требования на 8.*

## Содержание 
- [Начало](#отчёт-домашнее-задание-1-вариант-3)
- [Выполнено на 4](#4-балла) 
- [Выполнено на 5](#5-баллов) 
- [Выполнено на 6](#6-баллов) 
- [Выполнено на 7](#7-баллов) 
- [Выполнено на 8](#8-баллов) 
- [Завершение](#конец-отчета)

## 4 балла
**Путь:** 
[./4_points](./4_points)
- Решение на языке С представлено в файле [**main.c**](./4_points/main.c) (не используются глобальные переменные)
- Откомпилирована ассемблерная программа, добавлены комментарии, поясняющие использование переменных в языке С и печать информации.
```sh
$gcc -masm=intel -S main.c
```
Добавлены поясняющие комментарии в блоки .main и основные .Lxx.\
Конечный файл [**main.s**](./4_points/) переименован в [**main[with_macros_commented].s**](./4_points/main%5Bwith_macros_commented%5D.s)\
Программа откомпилирована без опций отладки.
```sh
$gcc main[with_macros_commented].s
```
Файл [**a.out**](./4_points/) переименован в [**main_macros_commented.out**](./4_points/main_macros_commented.out)

- Из ассемблерной программы убраны лишние макросы
```sh
$gcc -masm=intel -S -fno-asynchronous-unwind-tables \
>-fcf-protection=none main.c
```
Поясняющие комментарии все еще будут находится в [**main[with_macros_commented].s**](./4_points/main%5Bwith_macros_commented%5D.s)
Скомпилированная без опций отладки программа [**main.s**](./4_points/) переименована в [**main[without_any_macros_and_comments].s**](./4_points/main%5Bwithout_any_macros_and_comments%5D.s)
- Модифицированная ассемблерная программа откомпилирована
и скомпонована без использования опций отладки.
```sh
$gcc main[without_any_macros_and_comments].s
```
Файл [**a.out**](./4_points/) переименован в [**main_nomacros.out**](./4_points/main_nomacros.out)
- Тесты  и их результаты для обеих программ представлены в папке [**Tests**](./4_points/Tests/)
> В файле [*Tests.txt*](./4_points/Tests/Tests.txt) представлены 10 тестов.\
> В файле [*Resaults_f.txt*](./4_points/Tests/Resaults_f.txt) представлены результаты для первой программы.\
> В файле [*Resaults_s.txt*](./4_points/Tests/Resaults_s.txt) представлены результаты для второй программы.\
> Результаты одинаковы для обеих программ.


## 5 баллов
**Путь:** 
[./5_points](./5_points)
- Решение на языке С представлено в файле [**main_f.c**](./5_points/main_f.c) (используются локальные пременные и функции с предачей по параметрам)
```sh
int get_number_of_elements() {
  int n = 0;
  while (n <= 0 || n >= 10000) {
    printf("Введите число обьектов в массиве (от 1 до 10000): ");
    scanf("%d", &n);
  }
  return n;
}

void get_elements_A(int A[], int n) {
  for(int i = 0; i < n; ++i) {
      printf("Введите A[%d]: ", i);
      scanf("%d", &A[i]);
  }
}

void fill_elements_B(int A[], int B[], int n) {
  for (int i = 0; i < n-1; ++i) {
    B[i] = A[i] + A[i+1];
  }
}

void print_elements(int A[], int n) {
  for(int i = 0; i < n; ++i) {
    printf("%d ", A[i]);
  }
}
```
- В асемблерное представление программы в файле [**main[separated_into_func].s**](./5_points/main%5Bseparated_into_func%5D.s) добавлены комментарии описывающие передачу фактических параметров и перенос возвращаемого результата и связь между параметрами языка С и регистрами.
> **gcc** при сборке файла в ассемблер очень любит засовывать переменные в регистр, но затем помещать их на стек со случайным смещением.
- Скомпилированная программа [**main[separated_into_func].s**](./5_points/main%5Bseparated_into_func%5D.s) представлена в файле [**main_separated_into_func.out**](./5_points/main_separated_into_func.out)
> Тесты для прошлых программ также на ней выдают корректный результат.

## 6 баллов
**Путь:** 
[./6_points](./6_points)
- Выполнен рефакторинг программы на ассемблере за счет максимального использования регистров процессора. Программа на ассемблере в [**main[refactor_min_var].s**](./6_points/main%5Brefactor_min_var%5D.s)
> Стек нам не нравится, так? Будем использовать его меньше. Поэтому задействуем кучку дополнительных регистров для оптимизации работы. Да и код короче, наконец, стал, вот это чудо.
- В [**main[refactor_min_var].s**](./6_points/main%5Brefactor_min_var%5D.s) добавлены комментарии, поясняющих использование регистров вместо переменных исходной программы на C.
```sh
# Смотрите как теперь коротко выглядит функция по заполнению массива B!
# Так теперь она еще и быстрее...
fill_elements_B:
	lea	ecx, -2[rdx]
	xor	eax, eax
.L18:
	mov	edx, DWORD PTR 4[rdi+rax*4]
	add	edx, DWORD PTR [rdi+rax*4]
	mov	DWORD PTR [rsi+rax*4], edx
	mov	rdx, rax
	add	rax, 1
	cmp	rdx, rcx
	jne	.L18
.L16:
	ret
```
>Использование регистров позволяет нам неплохо уменьшить колличество конечного кода и избавится наконец от странного хода компилятора типа mov eax, 0 если можно использовать более быстрый метод xor eax, eax.
- Тесты  и их результаты для програмы представлены в папке [**Tests**](./6_points/Tests/)
> В файле [*Tests.txt*](./6_points/Tests/Tests.txt) представлены 10 тестов.\
> В файле [*Resaults_t.txt*](./6_points/Tests/Resaults_t.txt) представлены результаты для третьей программы.\
> Результаты одинаковы для всех трех программ.

## 7 баллов
**Путь:** 
[./7_points](./7_points)
- Выполнена реализация программы на ассемблере, в виде двух единиц компиляции (с файлами).\
Компиляцию можно производить как на основе двух единиц компиляции на коде С:
```sh
$gcc -c functions.c -o functions.o
$gcc -c main_fiels.c -o main_files.o
$gcc functions.o main_files.o -o main_files_sep
```
Конечный исполняемый файл представлен в [**main_files_sep**](./7_points/main_fiels_sep).\
Так и на основе ассемблерного кода с помощью [**makefile**](./7_points/makefile):
```sh
$make -f makefile
```
Две единицы компиляции представлены c помощью файлов [**functions.o**](./7_points/functions.o) и [**main_files.o**](./7_points/main_files.o).
> Можете также обратить внимания на исходные файлы на С в файлах [**main_fiels.c**](./7_points/main_files.c), [**functions.h**](./7_points/functions.h) и [**fuenctions.c**](./7_points/functions.c).
- Добавлена возможность задания файлов с исходными данными и файла для вывода результатов с использованием аргументов командной строки. Исходный код на С находится в [**main_files.c**](./7_points/main_files.c), в свою очередь ассемблерный в [**main[files_command].s**](./7_points/main%5Bfiles_command%5D.s). Скомпилированы два исполняемых файла [**main_files**](./7_points/main_files) и [**main_files.out**](./7_points/main_files.out)
```sh
$./main_files ./in.txt ./out.txt
```
Если не заданы файлы, то программа продолжает работу в обычном режиме.
```sh
$./main_files
```
То же можно реализовать и с помошью скомпилированного ассемблерного кода [**main_files.out**](./7_points/main_files.out)
```sh
$./main_files.out ./in.txt ./out.txt
```
Если не заданы файлы, то программа продолжает работу в обычном режиме.
```sh
$./main_files.out
```
- Тесты  и их результаты для програмы представлены в папке [**Tests**](./7_points/Tests/)
> В файле [*Tests.txt*](./7_points/Tests/Tests.txt) представлены 10 тестов.\
> В файле [*Resaults_f.txt*](./7_points/Tests/Resaults_f.txt) представлены результаты для четвертой программы. *(результаты у ассемблерной программы и С совпадают)*\
> Результаты одинаковы для всех четырех программ (остутствует вывод массива A, что не влияет на конечный ответ в виде массива B).

## 8 баллов
**Путь:** 
[./8_points](./8_points)
- Добавлен генератор случайных наборов данных, расширяющий возможности тестирования
```sh
$./main_g
Выберете тип ввода.
-----------
1) Вручную
2) Автоматически
Введите число (1 или 2):
```
Программа автоматически генерирует входные данные при выборе опции 2.
- Расширен анализ командной строки для выбора способа порождения
исходных данных.
```sh
$./main_g -g
Время исполнения программы: 0.000003
Ответ:
A[9] = 253 183 718 320 686 943 377 723 848 
B[8] = 436 901 1038 1006 1629 1320 1100 1571
```
Программа сразу генерирует исходные данные при использовании опции -g.\
Оригинальный исходный код вы можете найти в [**main_g.c**](./8_points/main_g.c) и исполняемом [**main_g**](./8_points/main_g)
> Генерация правда выполняет создания небольших обьемов входных данных для корректного отображения в консоли, с большими данными мы поиграем дальше, будем использовать довольно большие (размер 5-14МБ) файлы с вводом.
- Добавлены замеры во времени, которые не учитывают время ввода и вывода данных. 
```sh
  clock_t begin = clock();
  fill_elements_B(A, B, n);
  clock_t end = clock();
  double time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
  printf("Время исполнения программы: %f\n", time_spent);
```
- Увеличено времени работы минимум до 1 секунды, за счет зацикливания наполнения:
```sh
  // Увеличиваем время исполнения!
  for (size_t i = 0; i < 1000; i++)
  {
    fill_elements_B(A, B, n);
  }
```
Представленное зациклевание вы можете найти в файлах [**main_g_X1000.с**](./8_points/main_g_X1000.c) и рефакторинговой [**main_g_X1000.s**](./8_points/main_g_X1000.s). Исполняемые файлы [**main_g_X1000_C**](./8_points/main_g_X1000_C) и [**main_g_X1000_ASM.out**](./8_points/main_g_X1000_ASM.out).\
\
Перейдем к замерам.\
Для быстроты проведения использовалась генерация входных данных в файл [**in.txt**](./8_points/in.txt) и считывание времени через парсинг ответа программы с помощью **Python**.\
Проводилось 100 ссесий [при случайном размере от 500000 до 1000000] на одинаковых входных файлах с элементами массива A, где (-100000 < A[i] < 100000) для двух программ.\
 В среднем ассемблер оказался на **1,66%** быстрее при малых входных данных. \
 Однако при некоторых входных данных при ручном генерировании тестов размера чуть более **1000000** ассемблер начинает проигрывать С, уступая по скрости на **1,56%** *(примером таких входных данных является текущий [in.txt](./8_points/in.txt))*. К сожалению, не удалось установить с чем это связанно, возможно дело в текущей машине.
- Результаты тестирования для программ представлены в папке [**Tests**](./8_points/Tests/)
> В файле [*TimeTests.txt*](./8_points/Tests/TimeTests.txt) представлен автоматически сгенерированный отчет по времени для случайных тестов.


# Конец отчета
![](./images/g.gif) ![](./images/e.gif)
